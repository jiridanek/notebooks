# Build Pipelines

This project uses multiple pipelines to build workbench images.
Each pipeline is used in its own appropriate setting.

## Chained builds

Dockerfiles in this repository are structured so that building a final images requires performing multiple Docker builds,
where the input of the previous build becomes the `FROM` input of the next one.

So-called *base* images have a concrete `FROM` image already specified in the Dockerfile.
Subsequent images in the chain use a build argument in their Dockerfiles, i.e. `FROM ${BASE_IMAGE}`.
To build such image, it's necessary to specify `--build-arg=BASE_IMAGE=...`.
This parameterization is necessary because one image may appear in more than one build chain in multiple different positions.

Each build pipeline requires the knowledge of the structure of the build chains.
We use the Makefile as the source of truth for the build chain structure,
but for some pipelines, this structure from Makefile needs to be reflected manually.

## 1. Makefile

Makefile encodes the build chain structure in the form of target dependencies.

```makefile
# Build and push cuda-jupyter-minimal-ubi9-python-3.11 image to the registry
.PHONY: cuda-jupyter-minimal-ubi9-python-3.11
cuda-jupyter-minimal-ubi9-python-3.11: cuda-ubi9-python-3.11
	$(call image,$@,jupyter/minimal/ubi9-python-3.11,$<)
```

This means that the `cuda-jupyter-minimal-ubi9-python-3.11` target uses the image built from `cuda-ubi9-python-3.11` as the `BASE_IMAGE` value.

The Makefile is maintained by hand and should serve as source of truth for the other pipelines.

## 2. OpenShift CI builds

https://github.com/openshift/release/blob/45c5060e6af1fe13a650ea1cf3eaf5d3d35c511d/ci-operator/config/opendatahub-io/notebooks/opendatahub-io-notebooks-main.yaml

Note that the build definitions are kept in a different repository.

```yaml
images:
- context_dir: .
  dockerfile_path: jupyter/minimal/ubi9-python-3.11/Dockerfile
  from: cuda-ubi9-python-3.11
  to: cuda-jupyter-minimal-ubi9-python-3.11
```

These build definitions drive the image release process.
The yaml files are edited by hand and should be kept in sync with the Makefile.
(Makefile is only used for local dev builds and in GitHub Actions CI.)

3. GitHub Actions

There are two mechanisms to specify a build pipeline in GitHub actions.

1. To build images after a branch push, there is `build-notebooks.yaml` workflow, that is autogenerated by `ci/cached-builds/gen_gha_matrix_jobs.py` from the Makefile.
   * the workflow creates a directed acyclic graph where vertices are the images and edges represent dependencies
   * github actions then process this graph in order to build all images specified
2. To build images when a pull request is proposed, there is `build-notebooks-pr.yaml` workflow, that again uses `ci/cached-builds/gen_gha_matrix_jobs.py` to generate build chains
   * this time, a dynamic matrix (`strategy.matrix: $(fromJSON(...))`) is created, for every leaf (=not intermediary) image target in the `Makefile`
   * only the chains that include images that were affected by the changes in the pull request are built, the others are skipped

The distinction is because while dynamic matrix is more flexible (it says _dynamic_ for a reason), dependencies between tasks in GitHub actions can only be specified statically.
Therefore, using dynamic matrix, it is not possible to define a build graph with intermediary nodes and dependencies.
On the other hand, with a statically defined graph, implementing the build skip for unchanged images would've been harder.

